---
alwaysApply: true
---

# AI Rules for MuShee

**MuShee** is a web-based sheet music library management application built with Angular 19 and TypeScript 5, enabling musicians to upload, organize, and render MusicXML files into readable sheet music using OpenSheetMusicDisplay. The application leverages Supabase for authentication, database storage, and file management, providing users with secure personal libraries and access to a pre-loaded collection of public domain compositions. An AI-powered recommendation engine integrated through OpenRouter.ai analyzes users' music collections to suggest similar pieces, enhancing music discovery. The system includes user feedback mechanisms for both rendering quality and AI suggestion relevance, enabling continuous improvement of the platform.

## Tech Stack

### Frontend

- Angular 19
- TypeScript 5
- Angular Material
- OpenSheetMusicDisplay

### Backend

- Supabase

### AI

- OpenRouter.ai

### CI/CD and Hosting

- GitHub Actions
- DigitalOcean

## Project Structure

When introducing changes to the project, always follow the directory structure below:

- `./src` - source code
- `./src/app` - Angular application components, services, and routes
- `./src/app/components` - Angular components
- `./src/app/services` - Angular services
- `./src/app/models` - TypeScript models and interfaces
- `./src/app/guards` - Route guards
- `./src/app/interceptors` - HTTP interceptors
- `./src/assets` - static internal assets
- `./public` - public assets (favicon, etc.)

When modifying the directory structure, always update this section.

## Coding practices

### Guidelines for clean code

- Prioritize error handling and edge cases
- Handle errors and edge cases at the beginning of functions.
- Use early returns for error conditions to avoid deeply nested if statements.
- Place the happy path last in the function for improved readability.
- Avoid unnecessary else statements; use if-return pattern instead.
- Use guard clauses to handle preconditions and invalid states early.
- Implement proper error logging and user-friendly error messages.
- Consider using custom error types or error factories for consistent error handling.
- Before implementing a new component similar to an existing one, ALWAYS examine the existing implementation first and follow its exact pattern. Flag any deviations explicitly.
- Before removing ANY Material imports, verify in the template that the component is NOT used. Cross-reference all Material components in both the template AND the template string. When in doubt, keep the import.
- When implementing computed signals that depend on form values, ensure the computed function calls the value signals to establish reactive dependencies. Verify in code review that reactivity is properly established.
- Computed signals that depend on form values MUST call the value signals inside their function body. Never access .value directly from FormControl - always go through signals.
- For form-based components using signals: Use toSignal(formControl.valueChanges) to convert form changes to signals. Computed signals automatically track dependencies when you call those signals inside them - DO NOT use effect() for this purpose. Use effect() only for side effects (logging, external system sync, etc.), not for establishing reactivity.

## Reference

- Refer to official documentation for components, services, and modules to ensure best practices and maintain code quality and maintainability.
